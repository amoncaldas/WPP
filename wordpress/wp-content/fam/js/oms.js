(function () { var e = !0, t = null, n = !1; (function () { var r, i = {}.hasOwnProperty, s = [].slice; if (((r = this.google) != t ? r.maps : void 0) != t) this.OverlappingMarkerSpiderfier = function () { function r(e, n) { var r, s, a, f, l = this; this.map = e; n == t && (n = {}); for (r in n) i.call(n, r) && (s = n[r], this[r] = s); this.e = new this.constructor.g(this.map); this.n(); this.b = {}; f = ["click", "zoom_changed", "maptypeid_changed"]; s = 0; for (a = f.length; s < a; s++) r = f[s], o.addListener(this.map, r, function () { return l.unspiderfy() }) } var o, a, f, l, c, p, d, m; p = r.prototype; m = [r, p]; l = 0; for (c = m.length; l < c; l++) f = m[l], f.VERSION = "0.3.3"; a = google.maps; o = a.event; c = a.MapTypeId; d = 2 * Math.PI; p.keepSpiderfied = n; p.markersWontHide = n; p.markersWontMove = n; p.nearbyDistance = 20; p.circleSpiralSwitchover = 9; p.circleFootSeparation = 23; p.circleStartAngle = d / 12; p.spiralFootSeparation = 26; p.spiralLengthStart = 11; p.spiralLengthFactor = 4; p.spiderfiedZIndex = 1e3; p.usualLegZIndex = 10; p.highlightedLegZIndex = 20; p.legWeight = 1.5; p.legColors = { usual: {}, highlighted: {} }; l = p.legColors.usual; f = p.legColors.highlighted; l[c.HYBRID] = l[c.SATELLITE] = "#fff"; f[c.HYBRID] = f[c.SATELLITE] = "#f00"; l[c.TERRAIN] = l[c.ROADMAP] = "#444"; f[c.TERRAIN] = f[c.ROADMAP] = "#f00"; p.n = function () { this.a = []; this.j = [] }; p.addMarker = function (r) { var i, s = this; if (r._oms != t) return this; r._oms = e; i = [o.addListener(r, "click", function (e) { return s.F(r, e) })]; this.markersWontHide || i.push(o.addListener(r, "visible_changed", function () { return s.o(r, n) })); this.markersWontMove || i.push(o.addListener(r, "position_changed", function () { return s.o(r, e) })); this.j.push(i); this.a.push(r); return this }; p.o = function (e, n) { if (e._omsData != t && (n || !e.getVisible()) && !(this.s != t || this.t != t)) return this.unspiderfy(n ? e : t) }; p.getMarkers = function () { return this.a.slice(0) }; p.removeMarker = function (e) { var n, r, i, s, a; e._omsData != t && this.unspiderfy(); n = this.m(this.a, e); if (0 > n) return this; i = this.j.splice(n, 1)[0]; s = 0; for (a = i.length; s < a; s++) r = i[s], o.removeListener(r); delete e._oms; this.a.splice(n, 1); return this }; p.clearMarkers = function () { var e, t, n, r, i, s, u, a; this.unspiderfy(); a = this.a; e = r = 0; for (s = a.length; r < s; e = ++r) { n = a[e]; t = this.j[e]; i = 0; for (u = t.length; i < u; i++) e = t[i], o.removeListener(e); delete n._oms } this.n(); return this }; p.addListener = function (e, n) { var r, i; ((i = (r = this.b)[e]) != t ? i : r[e] = []).push(n); return this }; p.removeListener = function (e, t) { var n; n = this.m(this.b[e], t); 0 > n || this.b[e].splice(n, 1); return this }; p.clearListeners = function (e) { this.b[e] = []; return this }; p.trigger = function () { var e, n, r, i, o, a; n = arguments[0]; e = 2 <= arguments.length ? s.call(arguments, 1) : []; n = (r = this.b[n]) != t ? r : []; a = []; i = 0; for (o = n.length; i < o; i++) r = n[i], a.push(r.apply(t, e)); return a }; p.u = function (e, t) { var n, r, i, s, o; i = this.circleFootSeparation * (2 + e) / d; r = d / e; o = []; for (n = s = 0; 0 <= e ? s < e : s > e; n = 0 <= e ? ++s : --s) n = this.circleStartAngle + n * r, o.push(new a.Point(t.x + i * Math.cos(n), t.y + i * Math.sin(n))); return o }; p.v = function (e, t) { var n, r, i, s, o; i = this.spiralLengthStart; n = 0; o = []; for (r = s = 0; 0 <= e ? s < e : s > e; r = 0 <= e ? ++s : --s) n += this.spiralFootSeparation / i + 5e-4 * r, r = new a.Point(t.x + i * Math.cos(n), t.y + i * Math.sin(n)), i += d * this.spiralLengthFactor / n, o.push(r); return o }; p.F = function (e, n) { var r, i, s, o, a, f, l, c, h; o = e._omsData != t; (!o || !this.keepSpiderfied) && this.unspiderfy(); if (o || this.map.getStreetView().getVisible() || "GoogleEarthAPI" === this.map.getMapTypeId()) return this.trigger("click", e, n); o = []; a = []; r = this.nearbyDistance; f = r * r; s = this.c(e.position); h = this.a; l = 0; for (c = h.length; l < c; l++) r = h[l], r.map != t && r.getVisible() && (i = this.c(r.position), this.f(i, s) < f ? o.push({ A: r, p: i }) : a.push(r)); return 1 === o.length ? this.trigger("click", e, n) : this.G(o, a) }; p.markersNearMarker = function (e, r) { var i, s, o, a, f, l, c, h, p, d; r == t && (r = n); if (this.e.getProjection() == t) throw "Must wait for 'idle' event on map before calling markersNearMarker"; i = this.nearbyDistance; f = i * i; o = this.c(e.position); a = []; h = this.a; l = 0; for (c = h.length; l < c; l++) if (i = h[l], !(i === e || i.map == t || !i.getVisible())) if (s = this.c((p = (d = i._omsData) != t ? d.l : void 0) != t ? p : i.position), this.f(s, o) < f && (a.push(i), r)) break; return a }; p.markersNearAnyOtherMarker = function () { var r, i, s, o, a, f, l, c, p, d, m, g; if (this.e.getProjection() == t) throw "Must wait for 'idle' event on map before calling markersNearAnyOtherMarker"; f = this.nearbyDistance; r = f * f; o = this.a; f = []; m = 0; for (s = o.length; m < s; m++) i = o[m], f.push({ q: this.c((l = (p = i._omsData) != t ? p.l : void 0) != t ? l : i.position), d: n }); m = this.a; i = l = 0; for (p = m.length; l < p; i = ++l) if (s = m[i], s.map != t && s.getVisible() && (o = f[i], !o.d)) { g = this.a; s = c = 0; for (d = g.length; c < d; s = ++c) if (a = g[s], s !== i && a.map != t && a.getVisible() && (a = f[s], (!(s < i) || a.d) && this.f(o.q, a.q) < r)) { o.d = a.d = e; break } } m = this.a; s = []; r = l = 0; for (p = m.length; l < p; r = ++l) i = m[r], f[r].d && s.push(i); return s }; p.z = function (e) { var t = this; return { h: function () { return e._omsData.i.setOptions({ strokeColor: t.legColors.highlighted[t.map.mapTypeId], zIndex: t.highlightedLegZIndex }) }, k: function () { return e._omsData.i.setOptions({ strokeColor: t.legColors.usual[t.map.mapTypeId], zIndex: t.usualLegZIndex }) } } }; p.G = function (t, n) { var r, i, s, u, f, l, c, p, d, v; this.s = e; v = t.length; r = this.C(function () { var e, n, r; r = []; e = 0; for (n = t.length; e < n; e++) p = t[e], r.push(p.p); return r }()); u = v >= this.circleSpiralSwitchover ? this.v(v, r).reverse() : this.u(v, r); r = function () { var e, n, r, h = this; r = []; e = 0; for (n = u.length; e < n; e++) s = u[e], i = this.D(s), d = this.B(t, function (e) { return h.f(e.p, s) }), c = d.A, l = new a.Polyline({ map: this.map, path: [c.position, i], strokeColor: this.legColors.usual[this.map.mapTypeId], strokeWeight: this.legWeight, zIndex: this.usualLegZIndex }), c._omsData = { l: c.position, i: l }, this.legColors.highlighted[this.map.mapTypeId] !== this.legColors.usual[this.map.mapTypeId] && (f = this.z(c), c._omsData.w = { h: o.addListener(c, "mouseover", f.h), k: o.addListener(c, "mouseout", f.k) }), c.setPosition(i), c.setZIndex(Math.round(this.spiderfiedZIndex + s.y)), r.push(c); return r }.call(this); delete this.s; this.r = e; return this.trigger("spiderfy", r, n) }; p.unspiderfy = function (n) { var r, i, s, a, f, l, c; n == t && (n = t); if (this.r == t) return this; this.t = e; a = []; s = []; c = this.a; f = 0; for (l = c.length; f < l; f++) i = c[f], i._omsData != t ? (i._omsData.i.setMap(t), i !== n && i.setPosition(i._omsData.l), i.setZIndex(t), r = i._omsData.w, r != t && (o.removeListener(r.h), o.removeListener(r.k)), delete i._omsData, a.push(i)) : s.push(i); delete this.t; delete this.r; this.trigger("unspiderfy", a, s); return this }; p.f = function (e, t) { var n, r; n = e.x - t.x; r = e.y - t.y; return n * n + r * r }; p.C = function (e) { var t, n, r, i, s; i = n = r = 0; for (s = e.length; i < s; i++) t = e[i], n += t.x, r += t.y; e = e.length; return new a.Point(n / e, r / e) }; p.c = function (e) { return this.e.getProjection().fromLatLngToDivPixel(e) }; p.D = function (e) { return this.e.getProjection().fromDivPixelToLatLng(e) }; p.B = function (e, n) { var r, i, s, o, a, f; s = a = 0; for (f = e.length; a < f; s = ++a) if (o = e[s], o = n(o), "undefined" === typeof r || r === t || o < i) i = o, r = s; return e.splice(r, 1)[0] }; p.m = function (e, n) { var r, i, s, o; if (e.indexOf != t) return e.indexOf(n); r = s = 0; for (o = e.length; s < o; r = ++s) if (i = e[r], i === n) return r; return -1 }; r.g = function (e) { return this.setMap(e) }; r.g.prototype = new a.OverlayView; r.g.prototype.draw = function () { }; return r }() }).call(this) }).call(this)